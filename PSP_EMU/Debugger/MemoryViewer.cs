using System.Windows.Forms;

/*
 This file is part of pspsharp.

 pspsharp is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 pspsharp is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with pspsharp.  If not, see <http://www.gnu.org/licenses/>.
 */
namespace pspsharp.Debugger
{


	using RuntimeContextLLE = pspsharp.Allegrex.compiler.RuntimeContextLLE;
	using IMemoryReader = pspsharp.memory.IMemoryReader;
	using MemoryReader = pspsharp.memory.MemoryReader;
	using MMIO = pspsharp.memory.mmio.MMIO;
	using Utilities = pspsharp.util.Utilities;

	/// 
	/// <summary>
	/// @author George
	/// </summary>
	public class MemoryViewer : javax.swing.JFrame
	{

		private const long serialVersionUID = 1L;
		private int visiblelines = 0;
		private int startaddress;

		public MemoryViewer()
		{
			//this.cpu = c;
			startaddress = Emulator.Processor.cpu.pc;
			initComponents();
			RefreshMemory();

			WindowPropSaver.loadWindowProperties(this);
		}

		public static char converttochar(int character)
		{
			if (character < 0x020 || character >= 0x07f && character <= 0x0a0 || character == 0x0ad)
			{
				return '.';
			}
			return (char)(character & 0x0ff);
		}

		private static sbyte safeRead8(Memory mem, int address)
		{
			sbyte value = 0;
			if (isAddressGood(address))
			{
				value = (sbyte) mem.read8(address);
			}
			return value;
		}

		public static bool isAddressGood(int address)
		{
			if (RuntimeContextLLE.LLEActive)
			{
				return MMIO.isAddressGood(address);
			}
			return Memory.isAddressGood(address);
		}

		public static Memory Memory
		{
			get
			{
				if (RuntimeContextLLE.LLEActive)
				{
					return RuntimeContextLLE.MMIO;
				}
				return Memory.Instance;
			}
		}

		public static string getMemoryView(int addr)
		{
			sbyte[] line = new sbyte[16];
			Memory mem = Memory;

			for (int i = 0; i < line.Length; i++)
			{
				line[i] = safeRead8(mem, addr + i);
			}

			return string.Format("{0:X8} : {1:X2} {2:X2} {3:X2} {4:X2} {5:X2} {6:X2} " + "{7:X2} {8:X2} {9:X2} {10:X2} {11:X2} {12:X2} {13:X2} {14:X2} " + "{15:X2} {16:X2} {17} {18} {19} {20} {21} {22} {23} {24} {25} {26} {27} {28} {29} {30} {31} {32}", addr, line[0], line[1], line[2], line[3], line[4], line[5], line[6], line[7], line[8], line[9], line[10], line[11], line[12], line[13], line[14], line[15], converttochar(line[0]), converttochar(line[1]), converttochar(line[2]), converttochar(line[3]), converttochar(line[4]), converttochar(line[5]), converttochar(line[6]), converttochar(line[7]), converttochar(line[8]), converttochar(line[9]), converttochar(line[10]), converttochar(line[11]), converttochar(line[12]), converttochar(line[13]), converttochar(line[14]), converttochar(line[15]));
		}

		public virtual void SafeRefreshMemory()
		{
			SwingUtilities.invokeLater(() =>
			{
			RefreshMemory();
			});
		}

		public virtual void RefreshMemory()
		{
			int addr = startaddress;
			taMemoryView.Text = "";

			visiblelines = taMemoryView.Height / taMemoryView.getFontMetrics(taMemoryView.Font).Height;
			for (int y = 0; y < visiblelines; y++)
			{
				if (y > 0)
				{
					taMemoryView.append("\n");
				}
				taMemoryView.append(getMemoryView(addr));
				addr += 16;
			}
		}

		/// <summary>
		/// This method is called from within the constructor to initialize the form.
		/// WARNING: Do NOT modify this code. The content of this method is always
		/// regenerated by the Form Editor.
		/// </summary>
		// <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
		private void initComponents()
		{

			AddressField = new javax.swing.JTextField();
			btnGoToAddress = new javax.swing.JButton();
			btnGoToSP = new javax.swing.JButton();
			btnDumpRawRam = new javax.swing.JButton();
			btnGoToVRAM = new javax.swing.JButton();
			jPanel1 = new javax.swing.JPanel();
			taMemoryView = new javax.swing.JTextArea();

			java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("pspsharp/languages/pspsharp"); // NOI18N
			Title = bundle.getString("MemoryViewer.title"); // NOI18N
			MinimumSize = new java.awt.Dimension(800, 380);
			PreferredSize = new java.awt.Dimension(800, 380);

			AddressField.Font = new java.awt.Font("Courier New", 0, 12); // NOI18N
			AddressField.HorizontalAlignment = javax.swing.JTextField.CENTER;
			AddressField.Text = "0x00000000"; // NOI18N
			AddressField.addKeyListener(new KeyAdapterAnonymousInnerClass(this));

			btnGoToAddress.Text = bundle.getString("MemoryViewer.btnGoToAddress.text"); // NOI18N
			btnGoToAddress.addActionListener(new ActionListenerAnonymousInnerClass(this));

			btnGoToSP.Text = bundle.getString("MemoryViewer.btnGoToSP.text"); // NOI18N
			btnGoToSP.addActionListener(new ActionListenerAnonymousInnerClass2(this));

			btnDumpRawRam.Text = bundle.getString("MemoryViewer.btnDumpRawRam.text"); // NOI18N
			btnDumpRawRam.addActionListener(new ActionListenerAnonymousInnerClass3(this));

			btnGoToVRAM.Text = bundle.getString("MemoryViewer.btnGoToVRAM.text"); // NOI18N
			btnGoToVRAM.addActionListener(new ActionListenerAnonymousInnerClass4(this));

			jPanel1.addComponentListener(new ComponentAdapterAnonymousInnerClass(this));

			taMemoryView.Editable = false;
			taMemoryView.Font = new java.awt.Font("Courier New", 0, 12); // NOI18N
			taMemoryView.Border = javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0));
			taMemoryView.addMouseWheelListener(new MouseWheelListenerAnonymousInnerClass(this));
			taMemoryView.addKeyListener(new KeyAdapterAnonymousInnerClass2(this));

			javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
			jPanel1.Layout = jPanel1Layout;
			jPanel1Layout.HorizontalGroup = jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(taMemoryView);
			jPanel1Layout.VerticalGroup = jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(taMemoryView, javax.swing.GroupLayout.DEFAULT_SIZE, 295, short.MaxValue);

			javax.swing.GroupLayout layout = new javax.swing.GroupLayout(ContentPane);
			ContentPane.Layout = layout;
			layout.HorizontalGroup = layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(AddressField, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(btnGoToAddress, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue).addComponent(btnGoToVRAM, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue).addComponent(btnGoToSP, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue).addComponent(btnDumpRawRam, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue)).addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue)).addContainerGap());
			layout.VerticalGroup = layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(btnDumpRawRam).addComponent(AddressField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent(btnGoToAddress).addComponent(btnGoToSP).addComponent(btnGoToVRAM)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, short.MaxValue).addContainerGap());

			pack();
		} // </editor-fold>//GEN-END:initComponents

		private class KeyAdapterAnonymousInnerClass : java.awt.@event.KeyAdapter
		{
			private readonly MemoryViewer outerInstance;

			public KeyAdapterAnonymousInnerClass(MemoryViewer outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			public void keyPressed(KeyEvent evt)
			{
				outerInstance.onKeyPressed(evt);
			}
		}

		private class ActionListenerAnonymousInnerClass : java.awt.@event.ActionListener
		{
			private readonly MemoryViewer outerInstance;

			public ActionListenerAnonymousInnerClass(MemoryViewer outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			public void actionPerformed(java.awt.@event.ActionEvent evt)
			{
				outerInstance.btnGoToAddressActionPerformed(evt);
			}
		}

		private class ActionListenerAnonymousInnerClass2 : java.awt.@event.ActionListener
		{
			private readonly MemoryViewer outerInstance;

			public ActionListenerAnonymousInnerClass2(MemoryViewer outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			public void actionPerformed(java.awt.@event.ActionEvent evt)
			{
				outerInstance.btnGoToSPActionPerformed(evt);
			}
		}

		private class ActionListenerAnonymousInnerClass3 : java.awt.@event.ActionListener
		{
			private readonly MemoryViewer outerInstance;

			public ActionListenerAnonymousInnerClass3(MemoryViewer outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			public void actionPerformed(java.awt.@event.ActionEvent evt)
			{
				outerInstance.btnDumpRawRamActionPerformed(evt);
			}
		}

		private class ActionListenerAnonymousInnerClass4 : java.awt.@event.ActionListener
		{
			private readonly MemoryViewer outerInstance;

			public ActionListenerAnonymousInnerClass4(MemoryViewer outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			public void actionPerformed(java.awt.@event.ActionEvent evt)
			{
				outerInstance.btnGoToVRAMActionPerformed(evt);
			}
		}

		private class ComponentAdapterAnonymousInnerClass : java.awt.@event.ComponentAdapter
		{
			private readonly MemoryViewer outerInstance;

			public ComponentAdapterAnonymousInnerClass(MemoryViewer outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			public void componentResized(java.awt.@event.ComponentEvent evt)
			{
				outerInstance.jPanel1ComponentResized(evt);
			}
		}

		private class MouseWheelListenerAnonymousInnerClass : java.awt.@event.MouseWheelListener
		{
			private readonly MemoryViewer outerInstance;

			public MouseWheelListenerAnonymousInnerClass(MemoryViewer outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			public void mouseWheelMoved(java.awt.@event.MouseWheelEvent evt)
			{
				outerInstance.taMemoryViewMouseWheelMoved(evt);
			}
		}

		private class KeyAdapterAnonymousInnerClass2 : java.awt.@event.KeyAdapter
		{
			private readonly MemoryViewer outerInstance;

			public KeyAdapterAnonymousInnerClass2(MemoryViewer outerInstance)
			{
				this.outerInstance = outerInstance;
			}

			public void keyPressed(KeyEvent evt)
			{
				outerInstance.taMemoryViewKeyPressed(evt);
			}
		}

	private void taMemoryViewKeyPressed(KeyEvent evt)
	{ //GEN-FIRST:event_taMemoryViewKeyPressed
			if (evt.KeyCode == KeyEvent.VK_DOWN)
			{
				startaddress += 16;
				evt.consume();
				RefreshMemory();
			}
			else if (evt.KeyCode == KeyEvent.VK_UP)
			{
				startaddress -= 16;
				evt.consume();
				RefreshMemory();
			}
			else if (evt.KeyCode == KeyEvent.VK_PAGE_UP)
			{
				startaddress -= 16 * visiblelines;
				evt.consume();
				RefreshMemory();
			}
			else if (evt.KeyCode == KeyEvent.VK_PAGE_DOWN)
			{
				startaddress += 16 * visiblelines;
				evt.consume();
				RefreshMemory();
			}
	} //GEN-LAST:event_taMemoryViewKeyPressed

	private void btnGoToAddressActionPerformed(java.awt.@event.ActionEvent evt)
	{ //GEN-FIRST:event_btnGoToAddressActionPerformed
			GoToAddress();
	} //GEN-LAST:event_btnGoToAddressActionPerformed

		private void GoToAddress()
		{
			string gettext = AddressField.Text;
			int value;
			try
			{
				value = Utilities.parseAddressExpression(gettext);
			}
			catch (Exception)
			{
				MessageBox.Show(this, java.util.ResourceBundle.getBundle("pspsharp/languages/pspsharp").getString("MemoryViewer.strInvalidAddress.text"));
				return;
			}
			startaddress = value;
			AddressField.Text = string.Format("0x{0:X8}", value);
			RefreshMemory();
		}

	private void taMemoryViewMouseWheelMoved(java.awt.@event.MouseWheelEvent evt)
	{ //GEN-FIRST:event_taMemoryViewMouseWheelMoved
			if (evt.WheelRotation > 0)
			{
				startaddress += 16;
				evt.consume();
				RefreshMemory();
			}
			else
			{
				startaddress -= 16;
				evt.consume();
				RefreshMemory();
			}
	} //GEN-LAST:event_taMemoryViewMouseWheelMoved

	private void btnGoToSPActionPerformed(java.awt.@event.ActionEvent evt)
	{ //GEN-FIRST:event_btnGoToSPActionPerformed
			startaddress = Emulator.Processor.cpu._sp;
			RefreshMemory();
	} //GEN-LAST:event_btnGoToSPActionPerformed

	private void btnDumpRawRamActionPerformed(java.awt.@event.ActionEvent evt)
	{ //GEN-FIRST:event_btnDumpRawRamActionPerformed
			File f = new File("ramdump.bin");
			BufferedOutputStream @out = null;
			try
			{
				@out = new BufferedOutputStream(new System.IO.FileStream(f, System.IO.FileMode.Create, System.IO.FileAccess.Write));
				IMemoryReader memoryReader = MemoryReader.getMemoryReader(MemoryMap.START_RAM, MemoryMap.SIZE_RAM, 1);
				for (int i = 0; i < MemoryMap.SIZE_RAM; i++)
				{
					@out.write(memoryReader.readNext());
				}
			}
			catch (IOException)
			{
				// Ignore exception
			}
			finally
			{
				Utilities.close(@out);
			}
	} //GEN-LAST:event_btnDumpRawRamActionPerformed

	private void onKeyPressed(KeyEvent evt)
	{ //GEN-FIRST:event_onKeyPressed
			if (evt.KeyCode == KeyEvent.VK_ENTER)
			{
				GoToAddress();
			}
	} //GEN-LAST:event_onKeyPressed

	private void btnGoToVRAMActionPerformed(java.awt.@event.ActionEvent evt)
	{ //GEN-FIRST:event_btnGoToVRAMActionPerformed
			startaddress = 0x04000000;
			RefreshMemory();
	} //GEN-LAST:event_btnGoToVRAMActionPerformed

		private void jPanel1ComponentResized(java.awt.@event.ComponentEvent evt)
		{ //GEN-FIRST:event_jPanel1ComponentResized
			// this is needed to override the size of the TextArea with text already present
			taMemoryView.MinimumSize = jPanel1.MinimumSize;
			taMemoryView.MaximumSize = jPanel1.MaximumSize;
			RefreshMemory();
		} //GEN-LAST:event_jPanel1ComponentResized

		public override void dispose()
		{
			Emulator.MainGUI.endWindowDialog();
			base.dispose();
		}
		// Variables declaration - do not modify//GEN-BEGIN:variables
		private javax.swing.JTextField AddressField;
		private javax.swing.JButton btnDumpRawRam;
		private javax.swing.JButton btnGoToAddress;
		private javax.swing.JButton btnGoToSP;
		private javax.swing.JButton btnGoToVRAM;
		private javax.swing.JPanel jPanel1;
		private javax.swing.JTextArea taMemoryView;
		// End of variables declaration//GEN-END:variables
	}

}